# 钱其琨 ｜ Part 1 | 模块一

## 简答题


### 第一题

最终执行结果为：打印出 10。

原因：
数组a中存放的方法执行时会在作用域中查找i最终找到i为10。

### 第二题

最终执行结果：报错无法在 tmp 声明前访问

原因：
只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。
代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

详细查了一下 暂时性死区（TDZ）产生的原因：
由let/const声明的变量，当它们包含的词法环境被实例化时会被创建，但只有在变量的词法绑定已经被求值运算后，才能够被访问。

参考资料：
[理解ES6中的暂时死区(TDZ)](https://segmentfault.com/a/1190000008213835)

### 第三题

```js
    let arr = [12,34,32,89,4]
    let min = Math.min(...arr)
```

### 第四题

使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；

使用let声明的变量，其作用域为该语句所在的代码块内，无法在其初始化前使用；

使用const声明的是常量，在后面出现的代码中不能再修改该常量的值，其作用域为该语句所在的代码块内，无法在其初始化前使用。

查询大量资料发现，let和const确实也存在变量提升 ecma文档中的定义

![let-const](.\/images\/letconst.png)




## 项目文件说明

- notes : 笔记
- code : 代码
